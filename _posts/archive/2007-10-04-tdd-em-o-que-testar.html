---
layout: post
title: "TDD em: O que testar?"
published: false
---

<p>Quando comecei a implantar desenvolvimento guiado por testes (<a title="Tudo sobre TDD" href="http://dojofloripa.wordpress.com/2007/09/10/tudo-sobre-tdd/">TDD</a>) na empresa em que trabalhava, tive a sorte de fazer parte de uma equipe de desenvolvedores bastante competente. Com apenas uma apresenta&ccedil;&atilde;o de poucos minutos e duas semanas de pr&aacute;tica, quase todos j&aacute; conseguiram captar que a ess&ecirc;ncia do TDD n&atilde;o &eacute; apenas valida&ccedil;&atilde;o de c&oacute;digo, mas tamb&eacute;m a especifica&ccedil;&atilde;o de determinada funcionalidade.</p>
<p>Tive apenas um caso em especial. Depois de algumas sess&otilde;es de <a title="Pair programming" href="http://en.wikipedia.org/wiki/Pair_programming">programa&ccedil;&atilde;o em par</a> passei o teclado para o companheiro. Ele virou pra mim e disse: &ldquo;T&aacute;, e agora?&rdquo;. N&oacute;s j&aacute; t&iacute;nhamos discutidos anteriomente o contexto da funcionalidade, mas mesmo assim ele estava repleto de d&uacute;vidas sobre o que realmente implementar</p>
<p>Para tentar esclarecer um pouco as d&uacute;vidas, fiz uma breve pesquisa na bibliografia e cheguei nos conceitos <strong>Right-BICEP</strong> e <strong>CORRECT</strong>.</p>
<ul>
<li><strong>Right</strong> &ndash; Are the results <strong>right</strong>?</li>
</ul>
<dl> <dd>Dados valores de entrada e seus respectivos valores de sa&iacute;da, verifica-se se a implementa&ccedil;&atilde;o esta de acordo, ou seja, se os resultados est&atilde;o certos.</dd> </dl>
<ul>
<li><strong>B</strong> &ndash;  Are all  the <strong>boundary</strong> conditions <strong>CORRECT</strong>?</li>
</ul>
<dl> <dd>Verificar se os valores est&atilde;o dentro do dom&iacute;nio, dos limites aceit&aacute;veis. Por exemplo, uma valida&ccedil;&atilde;o de preenchimento de um campo, ou ainda se este foi preenchido na formata&ccedil;&atilde;o adequada. Veja abaixo a descri&ccedil;&atilde;o do acr&ocirc;nimo CORRECT, que descreve algumas condi&ccedil;&otilde;es de limites. </dd> </dl>
<ul>
<li><strong>I</strong> &ndash;  Can  you check <strong>inverse</strong> relationships?</li>
</ul>
<dl> <dd>Alguns m&eacute;todos podem ser verificados aplicando a sua l&oacute;gica inversa. Por exemplo, para verificar o resultado de uma divis&atilde;o, podemos comparar o dividendo com a multiplica&ccedil;&atilde;o do divisor com o quociente, adicionado ao resto. </dd> </dl>
<ul>
<li><strong>C</strong> &ndash; Can you <strong>cross-check</strong> results usings other means?</li>
</ul>
<dl> <dd>Semelhante a rela&ccedil;&atilde;o inversa, podemos verificar os resultados por outros meios. Podemos certificar o sucesso de uma inser&ccedil;&atilde;o de uma elemento em um vetor, verificando se o tamanho deste antes da inser&ccedil;&atilde;o e acrescido de um, &eacute; igual o tamanho depois da inser&ccedil;&atilde;o <em>(1 + Ni = Ni+1)</em>. </dd> </dl>
<ul>
<li><strong>E</strong> &ndash; Can you force <strong>error</strong> conditions to happen?</li>
</ul>
<dl> <dd>Verificar como a aplica&ccedil;&atilde;o se comporta em situa&ccedil;&otilde;es adversas. Podemos for&ccedil;ar um erro simples, com uma passagem de par&acirc;metros incorreta, por exemplo. Mas n&atilde;o podemos esquecer dos outros diversos poss&iacute;veis problemas do dia-a-dia. Uma falha na comunica&ccedil;&atilde;o, espa&ccedil;o em disco que se acaba, mem&oacute;ria insuficiente, etc. Uma maneira de testar isso &eacute; a utiliza&ccedil;&atilde;o de objetos Mock?. Mas isso j&aacute; &eacute; pano para outra manga =) </dd> </dl>
<ul>
<li><strong>P</strong> &ndash; Are <strong>performance</strong> characteristics within bounds?</li>
</ul>
<dl> <dd>Nesse caso n&atilde;o queremos testar o desempenho em si, mas sim se a curva de desempenho se mant&eacute;m est&aacute;vel, mesmo variando os cen&aacute;rios. Suponha que os testes de uma busca em um vetor de tamanho <em>N</em> passam em tempo <em>t</em>. E se agora o vetor for de tamanho <em>N+M</em>, os testes continuam passando em tempo <em>t+m</em>? </dd> </dl>
<p>Como muitos dos problemas aparecem  na verifica&ccedil;&atilde;o das entradas e sa&iacute;das, &eacute; importante ter bem definido o seu dom&iacute;nio, ou limites (boundary). Felizmente temos mais uma ferramenta para nos ajudar nessa defini&ccedil;&atilde;o.</p>
<ul>
<li><strong>C</strong>onformance &ndash; Does the value conform to an expected format?</li>
</ul>
<dl> <dd>Verifica se o valor em quest&atilde;o esta de acordo com o formato estabelecido. Por exemplo, um CPF ou CNPJ, ou ainda uma estrutura mais complexa como uma &aacute;rvore bin&aacute;ria. </dd> </dl>
<ul>
<li><strong>O</strong>rdering &ndash; Is the set of values ordered or unordered as appropriate?</li>
</ul>
<dl> <dd>Diz respeito a ordena&ccedil;&atilde;o dos valores. Suponha os processos de uma cafeteira (bom exemplo!): colocarFiltro(), colocarPo(), colocarAgua(), servirCafe(). Esses processos necessariamente precisam estar nessa ordem, caso contr&aacute;rio ningu&eacute;m vai conseguir beber o valor de sa&iacute;da. </dd> </dl>
<ul>
<li><strong>R</strong>ange &ndash; Is the value within reasonable minimum and maximum values?</li>
</ul>
<dl> <dd>Dado valor deve estar dentro do dom&iacute;nio. Por exemplo, o preenchimento do ano de nascimento em um formul&aacute;rio [1900,2007]. </dd> </dl>
<ul>
<li><strong>R</strong>eference &ndash; Does the code reference anything external that isn&rsquo;t under direct control of the code itself?</li>
</ul>
<dl> <dd>Verificar se um cen&aacute;rio referencia ou depende de outro fora do seu escopo. Suponha um portal de compras. Antes de adicionar qualquer produto ao carrinho, o usu&aacute;rio deve ter iniciado uma sess&atilde;o (efetuado login). Existem pr&eacute; e p&oacute;s-condi&ccedil;&otilde;es que devem ser satisfeitas para passar o teste. </dd> </dl>
<ul>
<li><strong>E</strong>xistence &ndash; Does the value exist (e.g., is non-null, nonzero, present in a set, etc.)?</li>
</ul>
<dl> <dd>O teste mais intuitivo, acho. Verificar e um determinado valor de fato existe. Se certo par&acirc;metro foi preenchido. </dd> </dl>
<ul>
<li><strong>C</strong>ardinality &ndash; Are there exactly enough values?</li>
</ul>
<dl> <dd>Outro simples tamb&eacute;m. Se a cardinalidade, quantidade dos par&acirc;metros passados &eacute; suficiente. </dd> </dl>
<ul>
<li><strong>T</strong>ime (absolute and relative) &ndash; Is everything happening in order? At the right time? In time?</li>
</ul>
<dl> <dd>Devemos verificar se  execu&ccedil;&atilde;o de diversos processos em ordem. Cada um executando no momento certo. Lembra do exemplo da cafeteira? Tamb&eacute;m se aplica aqui. Eu disse que era um bom exemplo =). Voc&ecirc; tamb&eacute;m pode imaginar uma linha de produ&ccedil;&atilde;o. </dd> </dl>
<p>Acho que isso &eacute; um bom come&ccedil;o. Mas gostaria de deixar bem claro que isso n&atilde;o se trata de um guia, muito menos de uma receita de bolo. S&atilde;o apenas alguns lembretes para facilitar e aprimorar a implementa&ccedil;&atilde;o dos seus testes. Caso voc&ecirc; tenha se interessado neste t&oacute;pico e queira a vers&atilde;o <em>in extenso</em>, voc&ecirc; DEVE ler <a style="opacity: 1;" title="Pragmatic Unit Testing in Java with JUnit" href="http://www.amazon.com/Pragmatic-Unit-Testing-Java-JUnit/dp/0974514012/ref=pd_bbs_sr_1/102-9513108-4139315?ie=UTF8&amp;s=books&amp;qid=1191443706&amp;sr=1-1">Pragmatic Unit Testing in Java with JUnit</a>.</p>
<p>Feliz TDD!</p>
